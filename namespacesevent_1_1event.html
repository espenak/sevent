<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sevent: sevent::event Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sevent</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesevent.html">sevent</a>      </li>
      <li class="navelem"><a class="el" href="namespacesevent_1_1event.html">event</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sevent::event Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p><a class="el" href="namespacesevent_1_1socket.html" title="The socket namespace contains an implementation independent interface to all socket communication wit...">sevent::socket</a> has a single handler for all events, this namespace adds event-forwarding to multiple handlers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsevent_1_1event_1_1_buffer.html">Buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsevent_1_1event_1_1_event.html">Event</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsevent_1_1event_1_1_event_id_body_serialized.html">EventIdBodySerialized</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsevent_1_1event_1_1_handler_map.html">HandlerMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of event handlers to make it easier to route events.  <a href="classsevent_1_1event_1_1_handler_map.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsevent_1_1event_1_1_numeric_event_id.html">NumericEventId</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsevent_1_1event_1_1_string_event_id.html">StringEventId</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classsevent_1_1event_1_1_buffer.html">Buffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#aeb55b01ec4caa11aa3e70d4c41510a55">Buffer_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classsevent_1_1event_1_1_event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">Event_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsevent_1_1event_1_1_string_event_id.html">StringEventId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#ab44566aaffac3ddc3dc0ff45866b00f7">eventid_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsevent_1_1event_1_1_string_event_id.html">eventid_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#aba1ce95c28a3efa53aa16ce41e8ec902">eventid_t_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsevent_1_1event_1_1_handler_map.html">HandlerMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#aa09f8f98d0dd09c8bbce46b92c310add">HandlerMap_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsevent_1_1event_1_1_numeric_event_id.html">NumericEventId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#a98d838bb4ab120c8b786054435fed019">NumericEventId_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsevent_1_1event_1_1_string_event_id.html">StringEventId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#a7e4734874601b092dfed1347b1f9c2e3">StringEventId_ptr</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesevent_1_1event.html#ac5f2383651f15edaa022ae55a3b87ddf">simpleAllEventsHandler</a> (<a class="el" href="namespacesevent_1_1event.html#aa09f8f98d0dd09c8bbce46b92c310add">event::HandlerMap_ptr</a> eventHandlerMap, <a class="el" href="namespacesevent_1_1socket.html#ab6a9bbd05ad2c9e2961f57b48807ca54">socket::Facade_ptr</a> facade, <a class="el" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session, <a class="el" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">Event_ptr</a> event)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A "all events handler" which forwards incoming events to the handlers registered with the eventHandlerMap.  <a href="#ac5f2383651f15edaa022ae55a3b87ddf"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespacesevent_1_1socket.html" title="The socket namespace contains an implementation independent interface to all socket communication wit...">sevent::socket</a> has a single handler for all events, this namespace adds event-forwarding to multiple handlers. </p>
<h2><a class="anchor" id="Example"></a>
Example</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;boost/thread.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/thread/mutex.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/thread/condition_variable.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/utility.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/ref.hpp&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="sevent_8h.html">sevent/sevent.h</a>&quot;</span>


<span class="keyword">using namespace </span>sevent;
<span class="keyword">using</span> <a class="code" href="classsevent_1_1event_1_1_buffer.html">sevent::event::Buffer</a>;
<span class="keyword">using</span> <a class="code" href="classsevent_1_1event_1_1_event.html">sevent::event::Event</a>;
<span class="keyword">using</span> <a class="code" href="classsevent_1_1socket_1_1_address.html" title="A pair of (host, port).">sevent::socket::Address</a>;
boost::mutex stream_lock; <span class="comment">// Guard the print streams to avoid thread output intertwine</span>
<span class="keyword">typedef</span> boost::shared_ptr&lt;std::string&gt; <a class="code" href="namespacesevent_1_1serialize.html#a74d5cb202fbfea1e486b5958c53469a6">String_ptr</a>;


<span class="comment">// msgHandler() and dieHandler() handles received events.</span>
<span class="comment">// All data is downloaded before the handler is called.</span>
<span class="comment">//</span>
<span class="comment">// Notice that all handlers get a ReceiveEvent object, which</span>
<span class="comment">// contains the eventid. This means that we can use the same handler</span>
<span class="comment">// for multiple events!</span>
<span class="keywordtype">void</span> msgHandler(<a class="code" href="namespacesevent_1_1socket.html#ab6a9bbd05ad2c9e2961f57b48807ca54">socket::Facade_ptr</a> facade, <a class="code" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session,
                  <a class="code" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">event::Event_ptr</a> event)
{
    <a class="code" href="namespacesevent_1_1serialize.html#a74d5cb202fbfea1e486b5958c53469a6">String_ptr</a> msg = <span class="keyword">event</span>-&gt;first&lt;<a class="code" href="namespacesevent_1_1serialize.html#a74d5cb202fbfea1e486b5958c53469a6">String_ptr</a>&gt;(<a class="code" href="namespacesevent_1_1serialize.html#ae52dc8b20b8a6f6696502caebab40eba">serialize::String</a>);
    boost::lock_guard&lt;boost::mutex&gt; lock(stream_lock);

    std::cout &lt;&lt; <span class="stringliteral">&quot;==================================&quot;</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;MSG-event received!&quot;</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Event id:  &quot;</span> &lt;&lt; <span class="keyword">event</span>-&gt;eventid() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Data:      &quot;</span> &lt;&lt; *msg &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;==================================&quot;</span> &lt;&lt; std::endl;
    facade-&gt;service()-&gt;stop();
}

<span class="keywordtype">void</span> dieHandler(<a class="code" href="namespacesevent_1_1socket.html#ab6a9bbd05ad2c9e2961f57b48807ca54">socket::Facade_ptr</a> facade, <a class="code" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session,
                <a class="code" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">event::Event_ptr</a> event)
{
    boost::lock_guard&lt;boost::mutex&gt; lock(stream_lock);
    std::cout &lt;&lt; <span class="stringliteral">&quot;*** DIE-event received ***&quot;</span> &lt;&lt; std::endl;
    facade-&gt;service()-&gt;stop();
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
{
    <a class="code" href="namespacesevent_1_1socket.html#ab6a9bbd05ad2c9e2961f57b48807ca54">socket::Facade_ptr</a> facade = <a class="code" href="classsevent_1_1socket_1_1_facade.html#a5000b63fa3b46e7c585754a6be12ed16">socket::Facade::make</a>();
    <a class="code" href="namespacesevent_1_1socket.html#ab6a9bbd05ad2c9e2961f57b48807ca54">socket::Facade_ptr</a> facade2 = <a class="code" href="classsevent_1_1socket_1_1_facade.html#a5000b63fa3b46e7c585754a6be12ed16">socket::Facade::make</a>();

    <span class="comment">// Setup the eventhandlers</span>
    <a class="code" href="namespacesevent_1_1event.html#aa09f8f98d0dd09c8bbce46b92c310add">event::HandlerMap_ptr</a> eventHandlerMap = <a class="code" href="classsevent_1_1event_1_1_handler_map.html#a1a9f4cb2f1acb220d77643f33bf2d675">event::HandlerMap::make</a>();
    eventHandlerMap-&gt;addEventHandler(<span class="stringliteral">&quot;sevent::examples::Msg&quot;</span>, msgHandler);
    eventHandlerMap-&gt;addEventHandler(<span class="stringliteral">&quot;sevent::examples::Die&quot;</span>, dieHandler);

    <span class="comment">// Start 5 worker threads, and use the handler above for incoming events.</span>
    <span class="comment">// Worker threads poll for IO-events, and ends up running event-handlers</span>
    <span class="comment">// (registered above), so it is a good idea to start new threads or spawn</span>
    <span class="comment">// many worker threads if any event-handler does any time-consuming task.</span>
    facade-&gt;setWorkerThreads(5, boost::bind(<a class="code" href="namespacesevent_1_1event.html#ac5f2383651f15edaa022ae55a3b87ddf" title="A &amp;quot;all events handler&amp;quot; which forwards incoming events to the handlers registered with the e...">event::simpleAllEventsHandler</a>,
                                            eventHandlerMap,
                                            _1, _2, _3));
    facade2-&gt;setWorkerThreads(5, boost::bind(<a class="code" href="namespacesevent_1_1event.html#ac5f2383651f15edaa022ae55a3b87ddf" title="A &amp;quot;all events handler&amp;quot; which forwards incoming events to the handlers registered with the e...">event::simpleAllEventsHandler</a>,
                                             eventHandlerMap,
                                             _1, _2, _3));

    <span class="comment">// Create 2 listening sockets. YES we are running both the server and the</span>
    <span class="comment">// client in the same process within the same service (a facade contains a</span>
    <span class="comment">// single service, and a service is what receives IO-requests).</span>
    <span class="comment">// We could of course have created multiple facades, but it would not have</span>
    <span class="comment">// made any difference in this example.</span>
    <a class="code" href="namespacesevent_1_1socket.html#a33fa0eb741d461f559da788961ed2dc4">socket::Listener_ptr</a> listener1 = facade-&gt;listen(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 9091));
    <a class="code" href="namespacesevent_1_1socket.html#a33fa0eb741d461f559da788961ed2dc4">socket::Listener_ptr</a> listener2 = facade-&gt;listen(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 9092));
    <a class="code" href="namespacesevent_1_1socket.html#a33fa0eb741d461f559da788961ed2dc4">socket::Listener_ptr</a> listener3 = facade2-&gt;listen(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 3000));

    <span class="comment">// Make 2 sessions, one for each listening socket.</span>
    <span class="comment">// Notice that two of them is to the same listening socket!</span>
    <a class="code" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session1 = facade-&gt;connect(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 9091));
    <a class="code" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session2 = facade-&gt;connect(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 9091));
    <a class="code" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session3 = facade-&gt;connect(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 9092));
    <a class="code" href="namespacesevent_1_1socket.html#a4785aea99362e55dfa5446b01ade44a2">socket::Session_ptr</a> session4 = facade-&gt;connect(Address::make(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 3000)); <span class="comment">// Connect to a listener in facade2</span>

    <span class="comment">// All data must be deallocated on destruction, and it must have a</span>
    <span class="comment">// serializer. Shared pointers are deallocated on destruction, and we have</span>
    <span class="comment">// a StringSerializer (which does nothing to the string).</span>
    <a class="code" href="namespacesevent_1_1serialize.html#a74d5cb202fbfea1e486b5958c53469a6">String_ptr</a> hello = boost::make_shared&lt;std::string&gt;(<span class="stringliteral">&quot;Hello&quot;</span>);
    <a class="code" href="namespacesevent_1_1serialize.html#a74d5cb202fbfea1e486b5958c53469a6">String_ptr</a> world = boost::make_shared&lt;std::string&gt;(<span class="stringliteral">&quot;world&quot;</span>);

    <span class="comment">// Lets send a couple of events! Note that the received order is not</span>
    <span class="comment">// guaranteed, so we might die before all messages are received!</span>
    <a class="code" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">event::Event_ptr</a> helloEvent = <a class="code" href="classsevent_1_1event_1_1_event.html#a16cb6a2f13e0f98854554d2fe2851fb3">Event::make</a>(<span class="stringliteral">&quot;sevent::examples::Msg&quot;</span>,
                                              <a class="code" href="classsevent_1_1event_1_1_buffer.html#a6be501be79afffb54fdce29dbb1c67f9">Buffer::make</a>(hello, <a class="code" href="namespacesevent_1_1serialize.html#ae52dc8b20b8a6f6696502caebab40eba">serialize::String</a>));
    <a class="code" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">event::Event_ptr</a> worldEvent = <a class="code" href="classsevent_1_1event_1_1_event.html#a16cb6a2f13e0f98854554d2fe2851fb3">Event::make</a>(<span class="stringliteral">&quot;sevent::examples::Msg&quot;</span>,
                                              <a class="code" href="classsevent_1_1event_1_1_buffer.html#a6be501be79afffb54fdce29dbb1c67f9">Buffer::make</a>(world, <a class="code" href="namespacesevent_1_1serialize.html#ae52dc8b20b8a6f6696502caebab40eba">serialize::String</a>));
    facade-&gt;sendEvent(session1, helloEvent);
    facade-&gt;sendEvent(session4, worldEvent);

    <span class="comment">// Not that facade-&gt;sendEvent is a shortcut for:</span>
    <span class="keywordflow">if</span>(facade-&gt;isLocalSession(session1)) {
        session1-&gt;sendEvent(helloEvent); <span class="comment">// Serialize message, and send it via the session (socket communication)</span>
    } <span class="keywordflow">else</span> {
        facade-&gt;invokeAllEventsHandler(session1, helloEvent); <span class="comment">// Invoke handler directly</span>
    }

    <span class="comment">// Send the die event, which will invoke the dieHandler and kill the</span>
    <span class="comment">// service</span>
    facade-&gt;sendEvent(session4, <a class="code" href="classsevent_1_1event_1_1_event.html#a16cb6a2f13e0f98854554d2fe2851fb3">Event::make</a>(<span class="stringliteral">&quot;sevent::examples::Die&quot;</span>));


    <span class="comment">// Always nice to know who you are communicating with..</span>
    {
        boost::lock_guard&lt;boost::mutex&gt; lock(stream_lock);
        std::cout &lt;&lt; <span class="stringliteral">&quot;#Session 1# Local=&quot;</span> &lt;&lt; session1-&gt;getLocalEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot; Remote=&quot;</span> &lt;&lt; session1-&gt;getRemoteEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot;  Is local connection?: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; facade-&gt;isLocalSession(session1)
                  &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;#Session 2# Local=&quot;</span> &lt;&lt; session2-&gt;getLocalEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot; Remote=&quot;</span> &lt;&lt; session2-&gt;getRemoteEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot;  Is local connection?: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; facade-&gt;isLocalSession(session2)
                  &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;#Session 3# Local=&quot;</span> &lt;&lt; session3-&gt;getLocalEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot; Remote=&quot;</span> &lt;&lt; session3-&gt;getRemoteEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot;  Is local connection?: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; facade-&gt;isLocalSession(session3)
                  &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;#Session 4# Local=&quot;</span> &lt;&lt; session4-&gt;getLocalEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot; Remote=&quot;</span> &lt;&lt; session4-&gt;getRemoteEndpointAddress()
                  &lt;&lt; <span class="stringliteral">&quot;  Is local connection?: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; facade-&gt;isLocalSession(session4)
                  &lt;&lt; std::endl;
    }

    <span class="comment">// Wait for all work to finish. In this example this will happen</span>
    <span class="comment">// when the dieHandler calls facade-&gt;service()-&gt;stop().</span>
    facade-&gt;joinAllWorkerThreads();

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aeb55b01ec4caa11aa3e70d4c41510a55"></a><!-- doxytag: member="sevent::event::Buffer_ptr" ref="aeb55b01ec4caa11aa3e70d4c41510a55" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classsevent_1_1event_1_1_buffer.html">Buffer</a>&gt; <a class="el" href="namespacesevent_1_1event.html#aeb55b01ec4caa11aa3e70d4c41510a55">sevent::event::Buffer_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00013">13</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae28390c43d8baba3cb7d4e4730ba2e64"></a><!-- doxytag: member="sevent::event::Event_ptr" ref="ae28390c43d8baba3cb7d4e4730ba2e64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classsevent_1_1event_1_1_event.html">Event</a>&gt; <a class="el" href="namespacesevent_1_1event.html#ae28390c43d8baba3cb7d4e4730ba2e64">sevent::event::Event_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="event_2_event_8h_source.html#l00013">13</a> of file <a class="el" href="event_2_event_8h_source.html">Event.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab44566aaffac3ddc3dc0ff45866b00f7"></a><!-- doxytag: member="sevent::event::eventid_t" ref="ab44566aaffac3ddc3dc0ff45866b00f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsevent_1_1event_1_1_string_event_id.html">StringEventId</a> <a class="el" href="classsevent_1_1event_1_1_string_event_id.html">sevent::event::eventid_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_event_id_8h_source.html#l00013">13</a> of file <a class="el" href="_event_id_8h_source.html">EventId.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba1ce95c28a3efa53aa16ce41e8ec902"></a><!-- doxytag: member="sevent::event::eventid_t_ptr" ref="aba1ce95c28a3efa53aa16ce41e8ec902" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classsevent_1_1event_1_1_string_event_id.html">eventid_t</a>&gt; <a class="el" href="namespacesevent_1_1event.html#aba1ce95c28a3efa53aa16ce41e8ec902">sevent::event::eventid_t_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_event_id_8h_source.html#l00015">15</a> of file <a class="el" href="_event_id_8h_source.html">EventId.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa09f8f98d0dd09c8bbce46b92c310add"></a><!-- doxytag: member="sevent::event::HandlerMap_ptr" ref="aa09f8f98d0dd09c8bbce46b92c310add" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classsevent_1_1event_1_1_handler_map.html">HandlerMap</a>&gt; <a class="el" href="namespacesevent_1_1event.html#aa09f8f98d0dd09c8bbce46b92c310add">sevent::event::HandlerMap_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_handler_map_8h_source.html#l00025">25</a> of file <a class="el" href="_handler_map_8h_source.html">HandlerMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98d838bb4ab120c8b786054435fed019"></a><!-- doxytag: member="sevent::event::NumericEventId_ptr" ref="a98d838bb4ab120c8b786054435fed019" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classsevent_1_1event_1_1_numeric_event_id.html">NumericEventId</a>&gt; <a class="el" href="namespacesevent_1_1event.html#a98d838bb4ab120c8b786054435fed019">sevent::event::NumericEventId_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_numeric_event_id_8h_source.html#l00011">11</a> of file <a class="el" href="_numeric_event_id_8h_source.html">NumericEventId.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e4734874601b092dfed1347b1f9c2e3"></a><!-- doxytag: member="sevent::event::StringEventId_ptr" ref="a7e4734874601b092dfed1347b1f9c2e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classsevent_1_1event_1_1_string_event_id.html">StringEventId</a>&gt; <a class="el" href="namespacesevent_1_1event.html#a7e4734874601b092dfed1347b1f9c2e3">sevent::event::StringEventId_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_string_event_id_8h_source.html#l00011">11</a> of file <a class="el" href="_string_event_id_8h_source.html">StringEventId.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac5f2383651f15edaa022ae55a3b87ddf"></a><!-- doxytag: member="sevent::event::simpleAllEventsHandler" ref="ac5f2383651f15edaa022ae55a3b87ddf" args="(event::HandlerMap_ptr eventHandlerMap, socket::Facade_ptr facade, socket::Session_ptr session, Event_ptr event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sevent::event::simpleAllEventsHandler </td>
          <td>(</td>
          <td class="paramtype">event::HandlerMap_ptr&#160;</td>
          <td class="paramname"><em>eventHandlerMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socket::Facade_ptr&#160;</td>
          <td class="paramname"><em>facade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socket::Session_ptr&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event_ptr&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A "all events handler" which forwards incoming events to the handlers registered with the eventHandlerMap. </p>
<p>This is intentionally left really simple because one should create a custom allEventsHandler in all situations except testing/examples to keep error handling in the application, instead of just having the application crash.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the eventid is not in the map. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_handler_map_8cc_source.html#l00053">53</a> of file <a class="el" href="_handler_map_8cc_source.html">HandlerMap.cc</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Apr 11 2011 02:13:45 for sevent by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
